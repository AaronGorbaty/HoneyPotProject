#!/bin/bash

# Just in case, if we had accidentally passed in the wrong number of arguments
if [ $# -ne 3 ]; then
  echo "usage: $0 <container_name external_IP_address mitm_port>"
  exit 1
fi

# Note: For assigning a new configuration for the IP, we will pass in a random string for the CONTAINER_NAME argument
CONTAINER_NAME=$1
EXTERNAL_IP=$2
MITM_PORT=$3
DIRECTORY_NAME=""

if [ -z $(sudo lxc-ls "$CONTAINER_NAME") ]; then # If container does not exist...

  # Generate a random number within the specified range using OpenSSL
  random_hex=$(openssl rand -hex 1 | colrm 2)

  # The following if statements are used to randomly assign a configuration to the IP address:
  # Depending on the hex number generated by openssl we spin up the associated honeypot configuration
  if [[ $random_hex == "0" || $random_hex == "1" || $random_hex == "2" || $random_hex == "3" ]]
  then
    # Set the container name and directory name for where container log will be stored
    CONTAINER_NAME="SSH_$EXTERNAL_IP"
    DIRECTORY_NAME="control_honeypot"

    # Restore SSH Honeypot using snapshot
    # Note: snapshot already has openSSH installed
    # sleep command is to give container some time to start up
    sudo lxc-snapshot -n SSH_Honeypot -r snap0 -N $CONTAINER_NAME
    sudo lxc-start -n $CONTAINER_NAME
    sleep 6

  elif [[ $random_hex == "4" || $random_hex  == "5" || $random_hex == "6" || $random_hex == "7" ]]
  then
    # Set the container name and directory name for where container log will be stored
    CONTAINER_NAME="HTTP_$EXTERNAL_IP"
    DIRECTORY_NAME="HTTP_honeypot"

    # Restore HTTP Honeypot using snapshot
    # Note: snapshot has openSSH and Apache Server installed
    # sleep command is to give container some time to start up
    sudo lxc-snapshot -n HTTP_Honeypot -r snap0 -N $CONTAINER_NAME
    sudo lxc-start -n $CONTAINER_NAME
    sleep 6

  elif [[ $random_hex == "8" || $random_hex  == "9" || $random_hex == "a" || $random_hex == "b" ]]
  then
    # Set the container name and directory name for where container log will be stored
    CONTAINER_NAME="HTTPS_$EXTERNAL_IP"
    DIRECTORY_NAME="HTTPS_honeypot"

    # Restore HTTPS Honeypot using snapshot
    # Note: snapshot has openSSH and Apache Secure installed
    # sleep command is to give container some time to start up
    sudo lxc-snapshot -n HTTPS_Honeypot -r snap0 -N $CONTAINER_NAME
    sudo lxc-start -n $CONTAINER_NAME
    sleep 6

  elif [[ $random_hex == "c" || $random_hex == "d" || $random_hex == "e" || $random_hex == "f" ]]
  then
    # Set the container name and directory name for where container log will be stored
    CONTAINER_NAME="SMTP_$EXTERNAL_IP"
    DIRECTORY_NAME="SMTP_honeypot"

    # Restore SMTP Honeypot using snapshot
    # Note: snapshot has openSSH and postfix server installed
    # sleep command is to give container some time to start up
    sudo lxc-snapshot -n SMTP_Honeypot -r snap0 -N $CONTAINER_NAME
    sudo lxc-start -n $CONTAINER_NAME
    sleep 6

  fi

  # Assign container to external IP address, through pre-routing and post-routing rules
  sudo sysctl -w net.ipv4.conf.all.route_localnet=1
  CONTAINER_IP=$(sudo lxc-info $CONTAINER_NAME -iH)
  # If statement is used just in case if CONTAINER_IP is an empty string, a problem that occurs occasionally
  if [ -z "$CONTAINER_IP" ]; then
    sleep 5
    CONTAINER_IP=$(sudo lxc-info $CONTAINER_NAME -iH)
  fi
  sudo ip addr add $EXTERNAL_IP/24 brd + dev eth1
  sudo iptables --table nat --insert PREROUTING --source 0.0.0.0/0 --destination $EXTERNAL_IP --jump DNAT --to-destination $CONTAINER_IP
  sudo iptables --table nat --insert POSTROUTING --source $CONTAINER_IP --destination 0.0.0.0/0 --jump SNAT --to-source $EXTERNAL_IP
  
  # Port forwarding ssh traffic to MITM and other routing rules
  sudo iptables --table nat --insert PREROUTING --source 0.0.0.0/0 --destination $EXTERNAL_IP --protocol tcp --dport 22 --jump DNAT --to-destination 10.0.3.1:$MITM_PORT

  # Start MITM server, running the forever command to be listening on a specific port
  # LOG_FILE variable is used to set the name of our log file
  LOG_FILE="$CONTAINER_NAME.log -> $(date)"
  sudo forever -l /home/student/host_logs/$DIRECTORY_NAME/"$LOG_FILE" -a start --uid "mitm_id_$CONTAINER_NAME" /home/student/MITM/mitm.js -n $CONTAINER_NAME -i $CONTAINER_IP -p $MITM_PORT --auto-access --auto-access-fixed 1 --debug --mitm-ip 10.0.3.1

  # Call attacker detection script with the necessary arguments
  /home/student/scripts/attacker_detection.sh /home/student/host_logs/$DIRECTORY_NAME/"$LOG_FILE" $CONTAINER_NAME $EXTERNAL_IP $MITM_PORT &

else
  # Attacker detection script triggers this section when it is time to recycle the container, beginning with deleting the existing one first
  # If container already exists delete container and iptables rules
  CONTAINER_IP=$(sudo lxc-info $CONTAINER_NAME -iH)
  # Once again, if statement to double check if CONTAINER_IP is empty string, as it is a problem that occurs occasionally
  if [ -z "$CONTAINER_IP" ]; then
    sleep 5
    CONTAINER_IP=$(sudo lxc-info $CONTAINER_NAME -iH)
  fi
  sudo ip addr delete $EXTERNAL_IP/24 brd + dev eth1
  sudo iptables --table nat --delete POSTROUTING --source $CONTAINER_IP --destination 0.0.0.0/0 --jump SNAT --to-source $EXTERNAL_IP
  sudo iptables --table nat --delete PREROUTING --source 0.0.0.0/0 --destination $EXTERNAL_IP --jump DNAT --to-destination $CONTAINER_IP
  sudo iptables --table nat --delete PREROUTING --source 0.0.0.0/0 --destination $EXTERNAL_IP --protocol tcp --dport 22 --jump DNAT --to-destination 10.0.3.1:$MITM_PORT

  # Stop the MITM instance for the container
  sudo forever stop "mitm_id_$CONTAINER_NAME"

  # Stop the container and destroy it, -f argument forces container to be destroyed even if running
  sudo lxc-destroy -f -n $CONTAINER_NAME

  # Call the recycling script again for the same IP to create another container, arguments don't matter as they will be set properly later
  /home/student/scripts/recycler.sh "yay" $EXTERNAL_IP $MITM_PORT &

fi
